#include <Eigen/Dense>
#include <iostream>
#include <cmath>
#include <numbers>
#include <vector>
#include <array>
#include <cassert>
#include <iomanip>

#include "petrine_library.h"


double deg_to_rad(double degrees)
{
    return degrees * 0.0174532925;
}

double rad_to_deg(double radians)
{
    return radians * 57.2957795;
}
const double PI = 3.14159265358979323846;
/*
//////////////////////////////////////////////Kode som skal flyttest til head
/////Oppgave 2b: Rotation Matrix from rotating about the x-axis
//Generated by Chat GPT 5.0
//Equation found in page 72, MR pre-print 2019
Eigen::Matrix3d rotate_x(double degrees)
{
    Eigen::Matrix3d matrix;
    // konvertere grader til radianer
    double theta = degrees * PI / 180.0;

    matrix << 1,          0,           0,
              0,  std::cos(theta), -std::sin(theta),
              0,  std::sin(theta),  std::cos(theta);

    return matrix;
}

void rotate_x_test() {
    Eigen::Matrix3d Rx = rotate_x(90.0); // 90 grader
    std::cout << "Rotation matrix Rx(90):\n" << Rx << std::endl;
}

//Oppgave 2c: Rotation Matrix from rotating about the y-axis
//Generated by Chat GPT 5.0
//Equation found in page 72, MR pre-print 2019
Eigen::Matrix3d rotate_y(double degrees)
{
    Eigen::Matrix3d matrix;
    double theta = degrees * PI / 180.0;


    matrix <<  std::cos(theta),  0,  std::sin(theta),
               0,                1,  0,
              -std::sin(theta),  0,  std::cos(theta);
    return matrix;
}
void rotate_y_test() {
    Eigen::Matrix3d Ry = rotate_y(90.0);
    std::cout << "Rotation matrix Ry(90):\n" << Ry << std::endl;
}

//Oppgave 2d: Rotation Matrix from rotating about the z-axis
//Generated by Chat GPT 5.0
//Equation found in page 72, MR pre-print 2019
Eigen::Matrix3d rotate_z(double degrees)
{
    Eigen::Matrix3d matrix;


    double theta = degrees * PI / 180.0;


    matrix <<  std::cos(theta), -std::sin(theta), 0,
               std::sin(theta),  std::cos(theta), 0,
               0,                0,               1;

    return matrix;
}

void rotate_z_test() {
    Eigen::Matrix3d Rz = rotate_z(90.0);
    std::cout << "Rotation matrix Rz(90):\n" << Rz << std::endl;
}

/////Oppgave 2f: Rotation Matrix from Euler angles (ZYX)
//Generated by Chat GPT 5.0
//Equation (B.2) page 579,Appendix B, MR pre-print 2019
Eigen::Matrix3d rotation_matrix_from_euler_zyx(const Eigen::Vector3d &e)
{
    double alpha = e(0); // rotasjon om z
    double beta  = e(1); // rotasjon om y
    double gamma = e(2); // rotasjon om x

    //i assignment 1 så er det ZYX, men her skal vi ha YZX så den er endra på
    Eigen::Matrix3d Rz = rotate_z(alpha);
    Eigen::Matrix3d Ry = rotate_y(beta);
    Eigen::Matrix3d Rx = rotate_x(gamma);

    Eigen::Matrix3d R = Eigen::Matrix3d::Identity() * Rz * Ry * Rx;  //zyx i denne
    return R;
}
//fra assignment1
Eigen::Matrix3d skew_symmetric(const Eigen::Vector3d &vec)   //Her brukes eigen for å kunne lage en matrise. Matrisen defineres ved hjelp av 3D vektor.
{
    Eigen::Matrix3d S;
    S <<      0.0,     -vec.z(),   vec.y(),
           vec.z(),      0.0,     -vec.x(),
          -vec.y(),     vec.x(),   0.0;
    return S;                                               // Her lager en først en tom matrise S som får gitte verdier og returnerer den med r.
}
//Oppgave 3a: Transformation matrix from a rotation matrix and translation vector
//Generated by Chat GPT 5.0
//Equation (3.62) page 87, MR pre-print 2019
// Oppg. 3a: Lag T av R og p
Eigen::Matrix4d transformation_matrix(const Eigen::Matrix3d &R,
                                      const Eigen::Vector3d &p)
{
    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();
    T.block<3,3>(0,0) = R;   // øvre venstre 3x3 = R
    T.block<3,1>(0,3) = p;   // øvre høyre 3x1 = p
    return T;                // siste rad er [0 0 0 1]
}
// ---- T3.a: Implement the matrix exponential for rotation matrices ----
//henta fra side 82 formel (3.51)
//heile oppgave 3 har ej fått hjep med han Magnus Mortensen. kreds til han <3
Eigen::Matrix3d matrix_exponential(const Eigen::Vector3d &w, double theta)
{
    double rad = deg_to_rad(theta);
    Eigen::Matrix3d R = Eigen::Matrix3d::Identity() + sin(rad) * skew_symmetric(w) + (1-cos(rad)) * skew_symmetric(w) * skew_symmetric(w);
    return R;
}
// ---- T3.c: Implement the matrix exponential for homogeneous transformation matrices ----
// MR 2019 - Formel (3.88) proposition 3.25 on page 103
/* Implement a function that creates a transformation matrix, T ∈ SE(3), from exponential coordinates, [S]θ ∈
 se(3).
Eigen::Matrix4d matrix_exponential(const Eigen::Vector3d &w, const Eigen::Vector3d &v, double theta) {
    double rad = deg_to_rad(theta);

    Eigen::Matrix3d R = matrix_exponential(w, theta); //fra 3a
    Eigen::Vector3d v_theta = ((Eigen::Matrix3d::Identity() * rad) + ((1-cos(rad)) * skew_symmetric(w)) + (rad - sin(rad)) * skew_symmetric(w) * skew_symmetric(w)) * v;

    Eigen::Matrix4d T = transformation_matrix(R, v_theta);
    return T;

}


// T.1 c) Screw axis fra q, s og pitch h
// Referanse:MR formula on page 101
Eigen::VectorXd screw_axis(const Eigen::Vector3d &q, const Eigen::Vector3d &s, double h) {
    Eigen::VectorXd S(6);
    Eigen::Vector3d v = -s.cross(q) + h*s;
    S << s, v;
    return S;
}*/
//////////////////////////////////////////////////NO KJEM OPPGAVA UNDER



//T.1 a) Create a function that converts between vector types.
//MADE BY ME <3 used chat to describe datatypes. Watched youtube vidoes on for loops.
Eigen::VectorXd std_vector_to_eigen(const std::vector<double> &v) {
    Eigen::VectorXd eigen(v.size());
    for (int i = 0; i < v.size(); i++) {
        eigen(i) = v[i];
    }
    return eigen;
}

//T.1 b) Compare a number to the average value of the last items in a collection.
//MADE BY ME <3 used youtube and got help from luca to make a testcode so that it would return letters and not numbers.
bool is_average_below_eps(const std::vector<double> &values, double eps = 10e-7, uint8_t n_values = 5u) {
    if (values.size() < n_values) {
        return false;
    }
    double sum = 0.0;
    for (int i = values.size() - n_values; i < values.size(); ++i) {
        sum += values[i];
    }
    double average = sum / double(n_values);
    if (eps <= average) return true;
    return false;
}
/*
//T.1 c) Construct the UR3e kinematic chain in space frame.
//MADE BY ME <3 I did not finish ur3e_fk_screw in assignment 2, so it will be implimentetd in this assignment.
//Method used is described page 119
Eigen::Matrix4d ur3e_fk_screw(const std::vector<double> &joint_positions) {

    const double H1 = 0.15185;
    const double L1 = 0.24355;
    const double L2 = 0.2132;
    const double W1 = 0.13105;
    const double H2 = 0.08535;
    const double W2 = 0.0921;

    //Matrix M
    Eigen::Matrix4d M;
    M<< 0, 0, 0, -(L1 + L2),
        0, 0, -1.0, -(W1 + W2),
        0, 1, 0, H1 - H2,
        0, 0, 0, 1.0;

    //S1
    Eigen::Vector3d w1(0.0,0.0,1.0);
    Eigen::Vector3d q1(0.0,0.0,0.0);
    Eigen::Vector3d s1 = screw_axis(q1,w1,0.0);
    Eigen::Vector3d v1 = s1.tail<3>();
    Eigen::Matrix4d E1 = matrix_exponential(w1, v1, joint_positions[0]);

    //S2
    Eigen::Vector3d w2(0.0,-1.0, 0.0);
    Eigen::Vector3d q2(0.0,0.0,H1);
    Eigen::Vector3d s2 = screw_axis(q2,w2,0.0);
    Eigen::Vector3d v2 = s2.tail<3>();
    Eigen::Matrix4d E2 = matrix_exponential(w2, v2, joint_positions[1]);

    //S3
    Eigen::Vector3d w3(0.0,-1.0,0.0);
    Eigen::Vector3d q3(-L1,0.0,H1);
    Eigen::Vector3d s3 = screw_axis(q3,w3,0.0);
    Eigen::Vector3d v3 = s3.tail<3>();
    Eigen::Matrix4d E3 = matrix_exponential(w3, v3, joint_positions[2]);

    //S4
    Eigen::Vector3d w4(0.0,-1.0,0.0);
    Eigen::Vector3d q4(-L1-L2,0.0,0.0);
    Eigen::Vector3d s4 = screw_axis(q4,w4,0.0);
    Eigen::Vector3d v4 = s4.tail<3>();
    Eigen::Matrix4d E4 = matrix_exponential(w4, v4, joint_positions[3]);

    //S5
    Eigen::Vector3d w5(0.0,0.0,-1.0);
    Eigen::Vector3d q5(-L1-L2,W1,H1);
    Eigen::Vector3d s5 = screw_axis(q5,w5,0.0);
    Eigen::Vector3d v5 = s5.tail<3>();
    Eigen::Matrix4d E5 = matrix_exponential(w5, v5, joint_positions[4]);

    //S6
    Eigen::Vector3d w6(0.0,-1,0.0);
    Eigen::Vector3d q6(-L1-L2,-W1,H1-H2);
    Eigen::Vector3d s6 = screw_axis(q6,w6,0.0);
    Eigen::Vector3d v6 = s6.tail<3>();
    Eigen::Matrix4d E6 = matrix_exponential(w6, v6, joint_positions[5]);


    return E1 * E2 * E3 * E4 * E5 * E6 * M;

}
//5B
Eigen::Matrix4d ur3e_fk_transform(const std::vector<double> &joint_positions) {
    const double H1 = 0.15185;
    const double L1 = 0.24355;
    const double L2 = 0.2132;
    const double W1 = 0.13105;
    const double H2 = 0.08535;
    const double W2 = 0.0921;

    //side 492 eller 592
    auto DH = [](double th, double a, double d, double al) {
        double theta_rad = deg_to_rad(th);
        const double ct = std::cos(theta_rad), st = std::sin(theta_rad);
        const double ca = std::cos(al), sa = std::sin(al);
        Eigen::Matrix4d T;
        T <<  ct, -st*ca,  st*sa,  a*ct,
              st,  ct*ca, -ct*sa,  a*st,
              0.0,     sa,     ca,     d,
              0.0,    0.0,    0.0,   1.0;
        return T;
    };

    Eigen::Matrix4d T1 = DH (joint_positions[0], 0.0, H1, PI/2);
    Eigen::Matrix4d T2 = DH (joint_positions[1], -L1, 0.0, 0.0);
    Eigen::Matrix4d T3 = DH (joint_positions[2], -L2, 0.0, 0.0);
    Eigen::Matrix4d T4 = DH (joint_positions[3], 0.0, W1, PI/2);
    Eigen::Matrix4d T5 = DH (joint_positions[4], 0.0, H2, -PI/2);
    Eigen::Matrix4d T6 = DH (joint_positions[5], 0.0, W2, 0.0);

    return T1 * T2 * T3 * T4 * T5 * T6;
}










//Here comes the actual T.1c:
//std::pair<Eigen::Matrix4d, std::vector<Eigen::VectorXd>> ur3e_space_chain();

*/

//T.1 d)
//MADE BY ME <3
//Equation found in page x, MR pre-print 2019




int main()
{
    Petrine::rotate_x(0.5);
    //T.1 a) TEST CODE
    std::vector<double> v = {1.0, 2.0, 3.0, 4.0};
    Eigen::VectorXd eigen = std_vector_to_eigen(v);
    std::cout << "Test 1.a:" << eigen.transpose() << std::endl;
    //T.1b) TEST CODE
    std::vector<double> values = {1.0, 2.0, 3.0, 4.0, 5.0};
    bool test1b = is_average_below_eps(values, 4.34,2);
    std::cout << "true Test 1.b:" << std::boolalpha << test1b << std::noboolalpha << std::endl;
    test1b = is_average_below_eps(values, 4.34,3);
    std::cout << "false Test 1.b:" << std::boolalpha << test1b << std::noboolalpha << std::endl;




    std::cout << "Hello, World!" << std::endl;
    return 0;
}
