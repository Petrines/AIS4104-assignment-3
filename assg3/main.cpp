#include <Eigen/Dense>
#include <iostream>
#include <cmath>
#include <numbers>
#include <vector>
#include <array>
#include <cassert>
#include <iomanip>

#include "petrine_library.h" //utsatte å bruke dictonary fordi eg ikkje hadde tid


double deg_to_rad(double degrees)
{
    return degrees * 0.0174532925;
}

double rad_to_deg(double radians)
{
    return radians * 57.2957795;
}

const double DEG_TO_RAD = 0.0174532925;
const double RAD_TO_DEG = 57.2957795;
const double PI = 3.14159265358979323846;

//////////////////////////////////////////// Gammel kode fra tidligere assignments:
/////Oppgave 2b: Rotation Matrix from rotating about the x-axis
//Generated by Chat GPT 5.0
//Equation found in page 72, MR pre-print 2019
Eigen::Matrix3d rotate_x(double degrees)
{
    Eigen::Matrix3d matrix;
    // konvertere grader til radianer
    double theta = degrees * PI / 180.0;

    matrix << 1,          0,           0,
              0,  std::cos(theta), -std::sin(theta),
              0,  std::sin(theta),  std::cos(theta);

    return matrix;
}

void rotate_x_test() {
    Eigen::Matrix3d Rx = rotate_x(90.0); // 90 grader
    std::cout << "Rotation matrix Rx(90):\n" << Rx << std::endl;
}

//Oppgave 2c: Rotation Matrix from rotating about the y-axis
//Generated by Chat GPT 5.0
//Equation found in page 72, MR pre-print 2019
Eigen::Matrix3d rotate_y(double degrees)
{
    Eigen::Matrix3d matrix;
    double theta = degrees * PI / 180.0;


    matrix <<  std::cos(theta),  0,  std::sin(theta),
               0,                1,  0,
              -std::sin(theta),  0,  std::cos(theta);
    return matrix;
}
void rotate_y_test() {
    Eigen::Matrix3d Ry = rotate_y(90.0);
    std::cout << "Rotation matrix Ry(90):\n" << Ry << std::endl;
}

//Oppgave 2d: Rotation Matrix from rotating about the z-axis
//Generated by Chat GPT 5.0
//Equation found in page 72, MR pre-print 2019
Eigen::Matrix3d rotate_z(double degrees)
{
    Eigen::Matrix3d matrix;


    double theta = degrees * PI / 180.0;


    matrix <<  std::cos(theta), -std::sin(theta), 0,
               std::sin(theta),  std::cos(theta), 0,
               0,                0,               1;

    return matrix;
}

void rotate_z_test() {
    Eigen::Matrix3d Rz = rotate_z(90.0);
    std::cout << "Rotation matrix Rz(90):\n" << Rz << std::endl;
}

/////Oppgave 2f: Rotation Matrix from Euler angles (ZYX)
//Generated by Chat GPT 5.0
//Equation (B.2) page 579,Appendix B, MR pre-print 2019
Eigen::Matrix3d rotation_matrix_from_euler_zyx(const Eigen::Vector3d &e)
{
    double alpha = e(0); // rotasjon om z
    double beta  = e(1); // rotasjon om y
    double gamma = e(2); // rotasjon om x

    //i assignment 1 så er det ZYX, men her skal vi ha YZX så den er endra på
    Eigen::Matrix3d Rz = rotate_z(alpha);
    Eigen::Matrix3d Ry = rotate_y(beta);
    Eigen::Matrix3d Rx = rotate_x(gamma);

    Eigen::Matrix3d R = Eigen::Matrix3d::Identity() * Rz * Ry * Rx;  //zyx i denne
    return R;
}
//fra assignment1
Eigen::Matrix3d skew_symmetric(const Eigen::Vector3d &vec)   //Her brukes eigen for å kunne lage en matrise. Matrisen defineres ved hjelp av 3D vektor.
{
    Eigen::Matrix3d S;
    S <<      0.0,     -vec.z(),   vec.y(),
           vec.z(),      0.0,     -vec.x(),
          -vec.y(),     vec.x(),   0.0;
    return S;                                               // Her lager en først en tom matrise S som får gitte verdier og returnerer den med r.
}
//Oppgave 3a: Transformation matrix from a rotation matrix and translation vector
//Generated by Chat GPT 5.0
//Equation (3.62) page 87, MR pre-print 2019
// Oppg. 3a: Lag T av R og p
Eigen::Matrix4d transformation_matrix(const Eigen::Matrix3d &R,
                                      const Eigen::Vector3d &p)
{
    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();
    T.block<3,3>(0,0) = R;   // øvre venstre 3x3 = R
    T.block<3,1>(0,3) = p;   // øvre høyre 3x1 = p
    return T;                // siste rad er [0 0 0 1]
}
// ---- T3.a: Implement the matrix exponential for rotation matrices ----
//henta fra side 82 formel (3.51)
//heile oppgave 3 har ej fått hjep med han Magnus Mortensen. kreds til han <3
Eigen::Matrix3d matrix_exponential(const Eigen::Vector3d &w, double theta)
{
    double rad = deg_to_rad(theta);
    Eigen::Matrix3d R = Eigen::Matrix3d::Identity() + sin(rad) * skew_symmetric(w) + (1-cos(rad)) * skew_symmetric(w) * skew_symmetric(w);
    return R;
}
// ---- T3.c: Implement the matrix exponential for homogeneous transformation matrices ----
// MR 2019 - Formel (3.88) proposition 3.25 on page 103
// Implement a function that creates a transformation matrix, T ∈ SE(3), from exponential coordinates, [S]θ ∈ se(3).
Eigen::Matrix4d matrix_exponential(const Eigen::Vector3d &w, const Eigen::Vector3d &v, double theta) {
    double rad = deg_to_rad(theta);

    Eigen::Matrix3d R = matrix_exponential(w, theta); //fra 3a
    Eigen::Vector3d v_theta = ((Eigen::Matrix3d::Identity() * rad) + ((1-cos(rad)) * skew_symmetric(w)) + (rad - sin(rad)) * skew_symmetric(w) * skew_symmetric(w)) * v;

    Eigen::Matrix4d T = transformation_matrix(R, v_theta);
    return T;

}


// T.1 c) Screw axis fra q, s og pitch h
// Referanse:MR formula on page 101
Eigen::VectorXd screw_axis(const Eigen::Vector3d &q, const Eigen::Vector3d &s, double h) {
    Eigen::VectorXd S(6);
    Eigen::Vector3d v = -s.cross(q) + h*s;
    S << s, v;
    return S;
}
// T.1 d) Adjoint matrix fra homogen transformasjon
// Referanse: MR Eq. (3.20) page 98
//Created partially with help from Chat GPT 5.0
Eigen::MatrixXd adjoint_matrix(const Eigen::Matrix4d &tf) {
    Eigen::Matrix3d R = tf.block<3,3>(0,0);
    Eigen::Vector3d p = tf.block<3,1>(0,3);

    Eigen::Matrix3d p_hat=skew_symmetric(p);

    Eigen::MatrixXd AdT(6,6);
    AdT.setZero();
    AdT.block<3,3>(0,0) = R;
    AdT.block<3,3>(3,3) = R;
    AdT.block<3,3>(3,0) = p_hat * R;

    return AdT;
}
// T.1 b) Twist fra ω og v**
//(3.70) side 96 *
// Formel lyder slik: V_b = [ω_b; v_b] ∈ R^6
Eigen::VectorXd twist(const Eigen::Vector3d &w, const Eigen::Vector3d &v) {
    Eigen::VectorXd V(6);
    V << w, v;
    return V;
}
// T.1 e) Cot(x)
double cot(double x) {
    return 1 / (std::sin(x) / std::cos(x)); // fordi tan = sin/cos
}
// ---- T3.b: Implement the matrix logarithm for rotation matrices ----
// MR 2019 - Formler 3.50 - 3.61 side 85-86
/*Implement the algorithm for calculating the matrix logarithm of a rotation matrix, R ∈ SO(3), to obtain the
exponential coordinates [ω]θ ∈ so(3).*/
std::pair<Eigen::Vector3d, double> matrix_logarithm(const Eigen::Matrix3d &r)
{
    double theta;
    Eigen::Vector3d w;

    if (r == Eigen::Matrix3d::Identity()) {
        theta = 0;
    }
    else {
        double trace_r = r.trace(); // Built-in eigen function for trace
        if (trace_r == -1) {
            theta = PI;
            w = (1 / sqrt(2 * (1 + r(2,2)))) * Eigen::Vector3d (r(0,2), r(1,2), 1 + r(2,2));
        }
        else {
            theta = acos(0.5 * (trace_r - 1));
            double w_n = 1 / 2*sin(theta);

            double w_1 = w_n * (r(2, 1) - r(1, 2));
            double w_2 = w_n * (r(0, 2) - r(2, 0));
            double w_3 = w_n * (r(1, 0) - r(0, 1));

            w = Eigen::Vector3d(w_1, w_2, w_3);
        }
    }

    return std::pair<Eigen::Vector3d, double>(w, theta);



}
// ---- T3.d: Implement the matrix logarithm for homogeneous transformation matrices ----
// MR 2019 - Følger algoritmen på side 104
/*Implement the algorithm for calculating the matrix logarithm of a transformation matrix, T ∈ SE(3), to obtain
 the exponential coordinates, [S]θ ∈ se(3).*/
std::pair<Eigen::VectorXd, double> matrix_logarithm(const Eigen::Matrix4d &t) {
    const Eigen::Matrix3d R = t.topLeftCorner<3,3>();
    const Eigen::Vector3d p = t.topRightCorner<3,1>();

    Eigen::Vector3d w;
    Eigen::Vector3d v;
    double theta;

    if (R == Eigen::Matrix3d::Identity()) {
        w = Eigen::Vector3d::Zero();
        v = p / p.norm();
        theta = p.norm();
    }
    else {
        std::pair<Eigen::Vector3d, double> m_log = matrix_logarithm(R);
        w = m_log.first;
        theta = m_log.second;
        const Eigen::Matrix3d skew_w = skew_symmetric(w);
        v = (((1/theta) * Eigen::Matrix3d::Identity()) - 0.5 * skew_w + ((1/theta) - 0.5* cot(theta/2)) * skew_w*skew_w) * p;
    }

    return std::pair<Eigen::VectorXd, double>(twist(w,v), theta);
}
////////////////////////////////////////////////UNDER HER STATRA ASSIGMENT3//////////////////////////////////////////

//T.1 a) Create a function that converts between vector types.
//MADE BY ME <3 used chat to describe datatypes. Watched youtube vidoes on for loops.
Eigen::VectorXd std_vector_to_eigen(const std::vector<double> &v) {
    Eigen::VectorXd eigen(v.size());
    for (int i = 0; i < v.size(); i++) {
        eigen(i) = v[i];
    }
    return eigen;
}

//T.1 b) Compare a number to the average value of the last items in a collection.
//MADE BY ME <3 used youtube and got help from Luca to make a testcode so that it would return letters and not numbers.
bool is_average_below_eps(const std::vector<double> &values, double eps = 10e-7, uint8_t n_values = 5u) {
    if (values.size() < n_values) {
        return false;
    }
    double sum = 0.0;
    for (int i = values.size() - n_values; i < values.size(); ++i) {
        sum += values[i];
    }
    double average = sum / double(n_values);
    if (eps <= average) return true;
    return false;
}

//T.1 c) Construct the UR3e kinematic chain in space frame. (will come after the task 5 code)
//MADE BY ME <3 I did not finish ur3e_fk_screw in assignment 2, so it will be implimentetd in this assignment. Got some help from Khadija and William.
//Method used is described page 119 exsample 4.5 page 125
Eigen::Matrix4d ur3e_fk_screw(const std::vector<double> &joint_positions) {

    const double H1 = 0.15185;
    const double L1 = 0.24355;
    const double L2 = 0.2132;
    const double W1 = 0.13105;
    const double H2 = 0.08535;
    const double W2 = 0.0921;

    //Matrix M
    Eigen::Matrix4d M;
    M<< 0, 0, 0, -(L1 + L2),
        0, 0, -1.0, -(W1 + W2),
        0, 1, 0, H1 - H2,
        0, 0, 0, 1.0;

    //S1
    Eigen::Vector3d w1(0.0,0.0,1.0);
    Eigen::Vector3d q1(0.0,0.0,0.0);
    Eigen::Vector3d s1 = screw_axis(q1,w1,0.0);
    Eigen::Vector3d v1 = s1.tail<3>();
    Eigen::Matrix4d E1 = matrix_exponential(w1, v1, joint_positions[0]);

    //S2
    Eigen::Vector3d w2(0.0,-1.0, 0.0);
    Eigen::Vector3d q2(0.0,0.0,H1);
    Eigen::Vector3d s2 = screw_axis(q2,w2,0.0);
    Eigen::Vector3d v2 = s2.tail<3>();
    Eigen::Matrix4d E2 = matrix_exponential(w2, v2, joint_positions[1]);

    //S3
    Eigen::Vector3d w3(0.0,-1.0,0.0);
    Eigen::Vector3d q3(-L1,0.0,H1);
    Eigen::Vector3d s3 = screw_axis(q3,w3,0.0);
    Eigen::Vector3d v3 = s3.tail<3>();
    Eigen::Matrix4d E3 = matrix_exponential(w3, v3, joint_positions[2]);

    //S4
    Eigen::Vector3d w4(0.0,-1.0,0.0);
    Eigen::Vector3d q4(-L1-L2,0.0,0.0);
    Eigen::Vector3d s4 = screw_axis(q4,w4,0.0);
    Eigen::Vector3d v4 = s4.tail<3>();
    Eigen::Matrix4d E4 = matrix_exponential(w4, v4, joint_positions[3]);

    //S5
    Eigen::Vector3d w5(0.0,0.0,-1.0);
    Eigen::Vector3d q5(-L1-L2,W1,H1);
    Eigen::Vector3d s5 = screw_axis(q5,w5,0.0);
    Eigen::Vector3d v5 = s5.tail<3>();
    Eigen::Matrix4d E5 = matrix_exponential(w5, v5, joint_positions[4]);

    //S6
    Eigen::Vector3d w6(0.0,-1,0.0);
    Eigen::Vector3d q6(-L1-L2,-W1,H1-H2);
    Eigen::Vector3d s6 = screw_axis(q6,w6,0.0);
    Eigen::Vector3d v6 = s6.tail<3>();
    Eigen::Matrix4d E6 = matrix_exponential(w6, v6, joint_positions[5]);


    return E1 * E2 * E3 * E4 * E5 * E6 * M;


}
//T.5 b) Calculate forward kinematics using homogeneous transformation matrices.
Eigen::Matrix4d ur3e_fk_transform(const std::vector<double> &joint_positions) {
    const double H1 = 0.15185;
    const double L1 = 0.24355;
    const double L2 = 0.2132;
    const double W1 = 0.13105;
    const double H2 = 0.08535;
    const double W2 = 0.0921;

    //side 492
    auto DH = [](double th, double a, double d, double al) {
        double theta_rad = deg_to_rad(th);
        const double ct = std::cos(theta_rad), st = std::sin(theta_rad);
        const double ca = std::cos(al), sa = std::sin(al);
        Eigen::Matrix4d T;
        T <<  ct, -st*ca,  st*sa,  a*ct,
              st,  ct*ca, -ct*sa,  a*st,
              0.0,     sa,     ca,     d,
              0.0,    0.0,    0.0,   1.0;
        return T;
    };

    Eigen::Matrix4d T1 = DH (joint_positions[0], 0.0, H1, PI/2);
    Eigen::Matrix4d T2 = DH (joint_positions[1], -L1, 0.0, 0.0);
    Eigen::Matrix4d T3 = DH (joint_positions[2], -L2, 0.0, 0.0);
    Eigen::Matrix4d T4 = DH (joint_positions[3], 0.0, W1, PI/2);
    Eigen::Matrix4d T5 = DH (joint_positions[4], 0.0, H2, -PI/2);
    Eigen::Matrix4d T6 = DH (joint_positions[5], 0.0, W2, 0.0);

    return T1 * T2 * T3 * T4 * T5 * T6;
}
//Testcode generated by ChatGPT 5.0
//4x4 pose matrise
void print_pose(const Eigen::Matrix4d& T)
{
    std::cout << "Pose matrix (T):" << std::endl;

    for (int i = 0; i < 4; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            std::cout << std::fixed << std::setprecision(4) << std::setw(10) << T(i, j) << " ";
        }
        std::cout << std::endl;
    }

    std::cout << std::endl;
}

//---------------------------Here comes the actual T.1c:------------------------------------//
//Har fått hjelp med Magnus
std::pair<Eigen::Matrix4d, std::vector<Eigen::VectorXd>> ur3e_space_chain() {
    // UR3e lengder
    double L1 = 0.24355;
    double L2 = 0.2132;
    double W1 = 0.13105;
    double W2 = 0.0921;
    double H1 = 0.1518;
    double H2 = 0.08535;

    //Rotasjonsakse (ω)
    std::vector<Eigen::Vector3d> w = {
        {0,0,1},
        {0,1,0},
        {0,1,0},
        {0,1,0},
        {0,0,-1},
        {0,1,0}
    };

    // Punkt på kvar akse (q)
    std::vector<Eigen::Vector3d> q = {
        {0.0,       0.0,        0.0      },
        {0.0,       0.0,        H1       },
        {0.0,       0.0,        H1       },
        {L1,        0.0,        H1       },
        {L1+L2,     0.0,        H1       },
        {L1+L2,     0.0,        H1-H2    }
    };

    std::vector<Eigen::VectorXd> s(6);

    for (int i = 0; i < s.size(); ++i) {
        s[i] = screw_axis(q[i], w[i], 0.0);
    }

    Eigen::Matrix4d M = Eigen::Matrix4d::Identity();
    M << -1, 0, 0, L1 + L2,
          0, 0, 1, W1 + W2,
          0, 1, 0, H1 - H2,
          0, 0, 0, 1;

    return {M, s};
}


//T.1 d) Calculate forward kinematics using the UR3e kinematic chain expressed in the space frame.
//Partially generated by Gemini 2.5 Pro and discussion with classmates
Eigen::Matrix4d ur3e_space_fk(const Eigen::VectorXd &joint_positions) {
    auto [M,S]  = ur3e_space_chain();

    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();

    for (int i = 0; i < S.size(); ++i) {
        const Eigen::Vector3d w = S[i].head<3>();
        const Eigen::Vector3d v = S[i].tail<3>();
        const double theta_deg = rad_to_deg(joint_positions[i]);

        T *= matrix_exponential(w, v, theta_deg);
    }

    return T*M;
}

// T.1 e) Construct the UR3e kinematic chain in body frame.
//Partially generated by ChatGPT 5.0 and discussion with classmates
// Equation (4.169), page 127, MR physical book reprint 2019 (version 10, june 2024)
std::pair<Eigen::Matrix4d, std::vector<Eigen::VectorXd>> ur3e_body_chain() {

    auto [M, S] = ur3e_space_chain();


    const Eigen::Matrix4d Minv = M.inverse();
    const Eigen::Matrix<double, 6, 6> AdMinv = adjoint_matrix(Minv);

    std::vector<Eigen::VectorXd> B;
    B.reserve(S.size());
    for (const auto& Si : S) {
        B.emplace_back(AdMinv * Si);  // 6x1
    }

    return {M, B};
}
// T.1 f) Calculate forward kinematics using the UR3e kinematic chain expressed in the body frame.
//Partially generated by ChatGPT 5.0 and discussion with classmates
// Denne funksjonen bruka body frame-formelen som gir samme resultat som space frame, og eg fekk hjelp av ChatGPT til å sikre at koden følge riktig rekkefølge og uttrykk.
Eigen::Matrix4d ur3e_body_fk(const Eigen::VectorXd &joint_positions)
{
    auto [M, S] = ur3e_body_chain();

    Eigen::Matrix4d T = M;
    for (int i = static_cast<int>(S.size()) - 1; i >= 0; --i) {
        const Eigen::Vector3d w = S[i].head<3>();
        const Eigen::Vector3d v = S[i].tail<3>();
        const double theta_deg =  rad_to_deg(joint_positions[i]);
        T *= matrix_exponential(w, v, theta_deg);
    }
    return T;
}
//T.1 g) Test the space and body kinematic chain functions.
//MADE BY the assignment

void ur3e_test_fk()
{
    std::cout << "Forward kinematics tests" << std::endl;
    print_pose(ur3e_space_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    print_pose(ur3e_body_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    std::cout << std::endl;
    print_pose(ur3e_space_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0, 0.0,-90.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    print_pose(ur3e_body_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0, 0.0,-90.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    std::cout << std::endl;
    print_pose(ur3e_space_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0,-180.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    print_pose(ur3e_body_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0,-180.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    std::cout << std::endl;
    print_pose(ur3e_space_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0,-90.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD));
    print_pose(ur3e_body_fk(std_vector_to_eigen(std::vector<double>{0.0, 0.0,-90.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD));
}
// T.2 a) Implement Newton-Raphson to find the root of a scalar function.
//Partially written with help from a youtube video and ChatGPT 5.0
// Section 6.2.1, page 194, MR physical book reprint 2019 (version 10, june 2024)
std::pair<uint32_t, double>newton_raphson_root_find(const std::function<double(double)>& f,
                         double x_0,
                         double dx_0 = 0.5,
                         double eps  = 1e-7)
{
    const uint32_t kMaxIt = 100;
    uint32_t it = 0;
    double x = x_0;
    double dx = dx_0;

    for (; it < kMaxIt; ++it) {
        double fx = f(x);
        if (std::abs(fx) < eps) break;


        double dfx = (f(x + dx) - f(x - dx)) / (2.0 * dx);

        if (std::abs(dfx) < 1e-12) {
            dx *= 0.5;
            if (dx < 1e-12) break;
            continue;
        }

        double step = fx / dfx;
        x -= step;

        if (std::abs(step) < eps) break;
    }

    return {it, x};
}
//T.2 b) Implement Gradient descent to find the minima of a scalar function.
//Partially written with help from a youtube video and ChatGPT 5.0
//Formula from some youtube video :)
std::pair<uint32_t, double>
gradient_descent_minimize(const std::function<double(double)>& f,
                          double x_0,
                          double gamma = 0.1,
                          double dx_0 = 0.5,
                          double eps = 1e-7)
{
    const uint32_t kMaxIt = 1000;
    uint32_t it = 0;
    double x = x_0;

    for (; it < kMaxIt; ++it) {

        double dfdx = (f(x + dx_0) - f(x - dx_0)) / (2.0 * dx_0);


        if (std::abs(dfdx) < eps) break;


        x -= gamma * dfdx;
    }

    return {it, x};
}
//T.2 c) Test the root finding functions.
//From assignment
void test_newton_raphson_root_find(const std::function<double(double)> &f, double x0)
{
    auto [iterations, x_hat] = newton_raphson_root_find(f, x0);
    std::cout << "NR root f, x0=" << x0 << "-> it=" << iterations << " x=" << x_hat << " f(x)=" <<
    f(x_hat) << std::endl;
}
void test_gradient_descent_minimize(const std::function<double(double)> &f, double x0)
{
    auto [iterations, x_hat] = gradient_descent_minimize(f, x0);
    std::cout << "GD root f, x0=" << x0 << "-> it=" << iterations << " x=" << x_hat << " f(x)=" <<
    f(x_hat) << std::endl;
}
void test_optimizations()
{
    std::cout << "Root finding tests" << std::endl;
    auto f1 = [](double x)
    {
        return (x- 3.0) * (x- 3.0)- 1.0;
    };
    test_newton_raphson_root_find(f1,-20.0);
    test_gradient_descent_minimize(f1,-20.0);
}
//T.3 a) Construct the space Jacobian.
//Partially written with help from Gemini AI
//Equation (5.11) page 153, MR physical book reprint 2019 (version 10, june 2024)
Eigen::MatrixXd ur3e_space_jacobian(const Eigen::VectorXd &current_joint_positions)
{
    auto [_, S] = ur3e_space_chain();
    const int dof = static_cast<int>(S.size());

    Eigen::MatrixXd J = Eigen::MatrixXd::Zero(6, dof);
    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();

    for (int i = 0; i < dof; ++i) {

        J.col(i) = adjoint_matrix(T) * S[i];

        const double theta = current_joint_positions[i];
        const Eigen::Vector3d w = S[i].head<3>();
        const Eigen::Vector3d v = S[i].tail<3>();

        T = T * matrix_exponential(w, v, theta);
    }
    return J;
}
//T.3 b) Construct the body Jacobian.
//Partially written with help from Gemini AI
//Equation (5.18) page 157, MR physical book reprint 2019 (version 10, june 2024)
Eigen::MatrixXd ur3e_body_jacobian(const Eigen::VectorXd &current_joint_positions) {

    auto [_, B] = ur3e_body_chain();

    const int dof = static_cast<int>(B.size());

    Eigen::MatrixXd Jb = Eigen::MatrixXd::Zero(6, dof);

    Eigen::Matrix4d T_akk = Eigen::Matrix4d::Identity();

    for (int i = dof - 1; i >= 0; --i)
    {
        const Eigen::VectorXd& Bi = B[i];
        const double theta_i = current_joint_positions(i);

        Eigen::MatrixXd Ad_T_akk = adjoint_matrix(T_akk); // 6x6
        Eigen::VectorXd Bi_theta = Ad_T_akk * Bi;         // 6x1

        Jb.col(i) = Bi_theta;

        const Eigen::Vector3d w = Bi.head<3>();
        const Eigen::Vector3d v = Bi.tail<3>();

        Eigen::Matrix4d Exp_Neg_B_theta = matrix_exponential(w, v, -theta_i);

        T_akk = T_akk * Exp_Neg_B_theta;
    }

    return Jb;
}
// T.3 c) Test the Jacobian functions.
//From assignment
//NOTAT TIL ALEKSANDER SKREDE:
// Merk: Dei tre siste matriseneparra blir ikkje heilt like.
// Eg veit at Jb ≈ Ad_Tbs * Js og Js ≈ Ad_Tsb * Jb, men trur forskjellen kjem av små numeriske feil.
// Det kan også vere uendelig med løsninga i en robot. Som dei sei, det finnes mange veia til roma.
// Eg fekk vertfall ikkje heilt fiksa det innan innlevering.
void ur3e_test_jacobian(const Eigen::VectorXd &joint_positions)
{
    Eigen::Matrix4d tsb = ur3e_body_fk(joint_positions);
    auto [m, space_screws] = ur3e_space_chain();
    Eigen::MatrixXd jb = ur3e_body_jacobian(joint_positions);
    Eigen::MatrixXd js = ur3e_space_jacobian(joint_positions);
    Eigen::MatrixXd ad_tsb = adjoint_matrix(tsb);
    Eigen::MatrixXd ad_tbs = adjoint_matrix(tsb.inverse());
    std::cout << "Jb: " << std::endl << jb << std::endl << "Ad_tbs*Js:" << std::endl << ad_tbs * js <<
    std::endl << std::endl;
    std::cout << "Js: " << std::endl << js << std::endl << "Ad_tsb*Jb:" << std::endl << ad_tsb * jb <<
    std::endl << std::endl;
    std::cout << "d Jb: " << std::endl << jb- ad_tbs * js << std::endl << std::endl;
    std::cout << "d Js: " << std::endl << js- ad_tsb * jb << std::endl << std::endl;
}
void ur3e_test_jacobian()
{
    std::cout << "Jacobian matrix tests" << std::endl;
    ur3e_test_jacobian(std_vector_to_eigen(std::vector<double>{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) *
    DEG_TO_RAD);
    ur3e_test_jacobian(std_vector_to_eigen(std::vector<double>{45.0,-20.0, 10.0, 2.5, 30.0,-50.0}) *
    DEG_TO_RAD);
}
// T.4 a) Implement a numerical inverse kinematics solver.
//Partially written with help from Gemini AI
//Section 6.2.2, page 194, MR physical book reprint 2019 (version 10, june 2024)
std::pair<size_t, Eigen::VectorXd> ur3e_ik_body(const Eigen::Matrix4d &t_sd, const Eigen::VectorXd
    &current_joint_positions, double gamma = 1e-2, double v_e = 4e-3, double w_e = 4e-3)
{    constexpr size_t max_iter = 1000;
    const double lambda = 1e-4;
    const double step_tol = 1e-6;

    size_t iter = 0;
    Eigen::VectorXd thetas = current_joint_positions;

    for (; iter < max_iter; ++iter)
    {
        const Eigen::Matrix4d T_sb  = ur3e_body_fk(thetas);
        const Eigen::Matrix4d T_err = (T_sb.inverse() * t_sd).eval();

        auto [Vb, _] = matrix_logarithm(T_err);
        const Eigen::Vector3d wb = Vb.head<3>();
        const Eigen::Vector3d vb = Vb.tail<3>();

        if (wb.norm() < w_e && vb.norm() < v_e) break;

        const Eigen::MatrixXd Jb = ur3e_body_jacobian(thetas); // 6 x n

        const Eigen::MatrixXd A = Jb * Jb.transpose()
                                + (lambda * lambda) * Eigen::MatrixXd::Identity(6, 6);
        const Eigen::VectorXd dtheta = gamma * (Jb.transpose() * A.ldlt().solve(Vb));

        if (dtheta.norm() < step_tol) { thetas += dtheta; break; }

        thetas += dtheta;

        for (int k = 0; k < thetas.size(); ++k)
            thetas[k] = std::atan2(std::sin(thetas[k]), std::cos(thetas[k]));
    }

    return {iter, thetas};
}


//T.4 b) Test the inverse kinematics solver.
//From the assignment
//NOTAT TIL ALEKSANDER SKREDE:
//Her er noko muffens da det er printa nokon store avvik og den sliter med å konvergere. men greier ikkje finne feilen.
//Har konkludert med at ein av hjelpefunksjonene må vere feil, men finner ikkje ut ka slags av dei :(
void ur3e_ik_test_pose(const Eigen::Vector3d &pos, const Eigen::Vector3d &zyx, const Eigen::VectorXd &j0)
{
    std::cout << "Test from pose" << std::endl;
    Eigen::Matrix4d t_sd = transformation_matrix(rotation_matrix_from_euler_zyx(zyx), pos);
    auto [iterations, j_ik] = ur3e_ik_body(t_sd, j0);
    Eigen::Matrix4d t_ik = ur3e_body_fk(j_ik);
    print_pose(t_ik);
    print_pose(t_sd);
    std::cout << "Converged after " << iterations << " iterations" << std::endl;
    std::cout << "J_0: " << j0.transpose() * RAD_TO_DEG << std::endl;
    std::cout << "J_ik: " << j_ik.transpose() * RAD_TO_DEG << std::endl << std::endl;
}
void ur3e_ik_test_configuration(const Eigen::VectorXd &joint_positions, const Eigen::VectorXd &j0)
{
    std::cout << "Test from configuration" << std::endl;
    Eigen::Matrix4d t_sd = ur3e_space_fk(joint_positions);
    auto [iterations, j_ik] = ur3e_ik_body(t_sd, j0);
    Eigen::Matrix4d t_ik = ur3e_body_fk(j_ik);
    print_pose(t_ik);
    print_pose(t_sd);
    std::cout << "Converged after " << iterations << " iterations" << std::endl;
    std::cout << "J_0: " << j0.transpose() * RAD_TO_DEG << std::endl;
    std::cout << "J_d: " << joint_positions.transpose() * RAD_TO_DEG << std::endl;
    std::cout << "J_ik: " << j_ik.transpose() * RAD_TO_DEG << std::endl << std::endl;
}
void ur3e_ik_test()
 {
 Eigen::VectorXd j_t0 = std_vector_to_eigen(std::vector<double>{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}) *
 DEG_TO_RAD;
 Eigen::VectorXd j_t1 = std_vector_to_eigen(std::vector<double>{0.0, 0.0,-89.0, 0.0, 0.0, 0.0}) *
 DEG_TO_RAD;
 ur3e_ik_test_pose(Eigen::Vector3d{0.3289, 0.22315, 0.36505}, Eigen::Vector3d{0.0, 90.0,-90.0} *
 DEG_TO_RAD, j_t0);
 ur3e_ik_test_pose(Eigen::Vector3d{0.3289, 0.22315, 0.36505}, Eigen::Vector3d{0.0, 90.0,-90.0} *
 DEG_TO_RAD, j_t1);
 Eigen::VectorXd j_t2 = std_vector_to_eigen(std::vector<double>{50.0,-30.0, 20, 0.0,-30.0, 50.0})
 * DEG_TO_RAD;
 Eigen::VectorXd j_d1 = std_vector_to_eigen(std::vector<double>{45.0,-20.0, 10.0, 2.5, 30.0,-50.0}) * DEG_TO_RAD;
 ur3e_ik_test_configuration(j_d1, j_t0);
 ur3e_ik_test_configuration(j_d1, j_t2);
 }

int main()
{
    Petrine::rotate_x(0.5);
    //T.1 a) TEST CODE
    std::vector<double> v = {1.0, 2.0, 3.0, 4.0};
    Eigen::VectorXd eigen = std_vector_to_eigen(v);
    std::cout << "Test 1.a:" << eigen.transpose() << std::endl;
    //T.1b) TEST CODE
    std::vector<double> values = {1.0, 2.0, 3.0, 4.0, 5.0};
    bool test1b = is_average_below_eps(values, 4.34,2);
    std::cout << "true Test 1.b:" << std::boolalpha << test1b << std::noboolalpha << std::endl;
    test1b = is_average_below_eps(values, 4.34,3);
    std::cout << "false Test 1.b:" << std::boolalpha << test1b << std::noboolalpha << std::endl;
//FANCY TEST HEHE
    std::cout << "===================================" << std::endl;
    std::cout << "     UR3e Forward Kinematics Test:" << std::endl;
    std::cout << "===================================" << std::endl << std::endl;

    ur3e_test_fk();

    std::cout << "===================================" << std::endl;
    std::cout << "           Test done!" << std::endl;
    std::cout << "===================================" << std::endl;
    /////////T.2) Testcode
    {
        auto f1 = [](double x){ return std::cos(x) - x; };
        std::cout << "Testing Newton-Raphson root finder:\n";
        test_newton_raphson_root_find(f1, 0.5);  // startverdi 0.5
        test_newton_raphson_root_find(f1, 1.0);  // startverdi 1.0 ekstra test
    }
        std::cout << "Testing Gradient Descent minimization:\n";
        // f(x) = (x - 3)^2  → minimum ved x = 3
        auto f1 = [](double x){ return std::pow(x - 3.0, 2); };
        test_gradient_descent_minimize(f1, 0.0);
        // f(x) = x^2  → minimum ved x = 0
        auto f2 = [](double x){ return x * x; };
        test_gradient_descent_minimize(f2, 5.0);
    std::cout << "===============================" << std::endl;
    std::cout << "  Testing optimization methods" << std::endl;
    std::cout << "===============================" << std::endl << std::endl;

    test_optimizations();

    std::cout << std::endl << "========== Test done ==========" << std::endl;
    //Task 3 Testcode
    std::cout << "===============================" << std::endl;
    std::cout << "  Testing Jacobien" << std::endl;
    std::cout << "===============================" << std::endl << std::endl;
    ur3e_test_jacobian();
    std::cout << std::endl << "========== Test done ==========" << std::endl;
    //T4 Testcode
    std::cout << "===============================" << std::endl;
    std::cout << "  Testing inverse kinematic" << std::endl;
    std::cout << "===============================" << std::endl << std::endl;
    ur3e_ik_test();
    std::cout << std::endl << "========== Test done ==========" << std::endl;


    std::cout << "Hello, World!" << std::endl;
    return 0;
}
